<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Maps Navigation</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Google Fonts: Roboto -->
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700;900&display=swap" rel="stylesheet">

    <!-- Phosphor Icons -->
    <script src="https://unpkg.com/@phosphor-icons/web"></script>

    <style>
        /* Base Settings */
        body, html { 
            height: 100%; 
            margin: 0; 
            padding: 0; 
            overflow: hidden; 
            background-color: #f8f9fa; 
            font-family: 'Roboto', sans-serif;
            -webkit-tap-highlight-color: transparent;
        }

        /* Map & 3D Wrapper */
        #map-wrapper {
            height: 100%;
            width: 100%;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 0; 
            perspective: 1200px; /* Strong perspective for 3D effect */
            overflow: hidden;
        }

        /* Map Size & Transform Origin */
        #map { 
            /* Large size to cover rotation edges */
            height: 400%; 
            width: 400%; 
            position: absolute;
            /* Perfectly centered relative to viewport */
            top: -150%;
            left: -150%;
            background: #e5e7eb;
            /* Critical for rotation alignment */
            transform-origin: center center;
            will-change: transform;
            /* Preserves 3D context for smoother rendering */
            transform-style: preserve-3d;
            backface-visibility: hidden; 
        }
        
        /* UI Layer - High Z-Index to stay on top */
        .map-ui { 
            z-index: 3000; 
            transform: translateZ(0);
        }

        /* Hide Leaflet Controls */
        .leaflet-control-zoom, .leaflet-control-attribution { display: none; }
        .leaflet-routing-container { display: none !important; }

        /* Custom Markers */
        .leaflet-marker-icon { transition: transform 0.1s linear; }
        .leaflet-marker-icon.nav-arrow-icon { transition: none !important; }
        .arrow-icon-inner { transform-origin: center; will-change: transform; }

        /* Material UI Shadows */
        .shadow-google { box-shadow: 0 1px 2px rgba(60,64,67,0.3), 0 2px 6px 2px rgba(60,64,67,0.15); }
        .shadow-floating { box-shadow: 0 6px 16px rgba(0,0,0,0.2); }

        /* Speed Limit Sign */
        .speed-limit-sign {
            width: 60px; 
            height: 60px; 
            background: white;
            border: 5px solid #cc0000;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Roboto', sans-serif;
            font-weight: 900;
            font-size: 24px; 
            color: #222;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            z-index: 3100;
        }
        
        @media (min-width: 768px) {
            .speed-limit-sign {
                width: 80px; 
                height: 80px;
                border-width: 6px;
                font-size: 32px;
            }
        }

        /* Pulse for User Location */
        @keyframes pulse-ring {
            0% { transform: scale(0.33); opacity: 0.8; }
            80%, 100% { opacity: 0; transform: scale(1.5); }
        }
        .user-pulse::before {
            content: '';
            position: absolute;
            height: 40px; width: 40px;
            left: -12px; top: -12px;
            border-radius: 50%;
            background-color: rgba(66, 133, 244, 0.4);
            animation: pulse-ring 2s cubic-bezier(0.215, 0.61, 0.355, 1) infinite;
        }

        /* --- GREEN BOX HEADER STYLES --- */
        #nav-icon svg {
            width: 100%;
            height: 100%;
            fill: none;
            stroke: #ffffff;
            stroke-width: 8;
            stroke-linecap: round;
            stroke-linejoin: round;
            filter: drop-shadow(0 2px 3px rgba(0,0,0,0.2));
        }

        .then-pill {
            transform: translateY(-100%);
            opacity: 0;
            transition: all 0.4s ease;
            z-index: -1;
        }
        .then-pill.visible {
            transform: translateY(0);
            opacity: 1;
        }
        
        /* Lane Icons */
        .lane-icon {
            font-size: 1.5rem; /* Mobile */
            color: rgba(255,255,255,0.4);
        }
        @media (min-width: 768px) {
            .lane-icon { font-size: 2rem; }
        }
        .lane-icon.active { color: white; }

        /* Mode Button Active State */
        .mode-active {
            background-color: #E8F0FE !important;
            color: #1967d2 !important;
        }
    </style>
</head>
<body class="text-gray-800">

    <div id="map-wrapper">
        <div id="map"></div>
    </div>

    <!-- ========================================== -->
    <!-- TOP SEARCH BAR (EXPLORE MODE)              -->
    <!-- ========================================== -->
    <div id="explore-ui" class="map-ui absolute top-0 left-0 right-0 p-4 transition-transform duration-300 pointer-events-none z-50">
        <div class="w-full md:w-96 relative z-50 pointer-events-auto mx-auto md:mx-0">
            <div class="bg-white rounded-full h-12 shadow-google flex items-center px-6 transition-all" id="search-box">
                <i class="ph-bold ph-magnifying-glass text-gray-400 text-xl mr-3"></i>
                <input type="text" id="search-input" 
                       placeholder="Search here" 
                       class="flex-1 bg-transparent outline-none text-base text-gray-700 placeholder-gray-500 font-normal h-full"
                       autocomplete="off" onkeypress="handleEnter(event)">
            </div>
            <!-- Search Results Dropdown -->
            <div id="search-results" class="hidden absolute top-14 left-0 right-0 bg-white rounded-xl shadow-google overflow-hidden max-h-[60vh] overflow-y-auto z-50">
            </div>
        </div>
    </div>

    <!-- ========================================== -->
    <!-- NAV HEADER                                 -->
    <!-- ========================================== -->
    <div id="nav-header" class="map-ui absolute top-0 left-0 right-0 p-4 md:p-6 transform -translate-y-[150%] transition-transform duration-500 pointer-events-none z-40 md:max-w-md md:left-6 md:right-auto">
        
        <!-- Main Green Card -->
        <div class="bg-[#064e3b] text-white rounded-2xl shadow-floating overflow-hidden relative z-20 pointer-events-auto flex flex-col">
            
            <div class="flex items-start p-4 md:p-6 gap-4">
                
                <!-- Turn Icon Container -->
                <div class="flex flex-col items-center shrink-0 -mt-1">
                    <!-- Icon size -->
                    <div id="nav-icon" class="w-16 h-16 md:w-20 md:h-20 flex items-center justify-center"></div>
                    <!-- Roundabout Exit Label -->
                    <div id="roundabout-exit-label" class="mt-1 md:mt-2 bg-white text-black text-lg md:text-xl font-black px-3 py-0.5 rounded shadow-lg hidden text-center min-w-[2.5rem]"></div>
                </div>

                <!-- Text Instruction -->
                <div class="flex-1 min-w-0 flex flex-col justify-center pt-1">
                    <!-- Text size -->
                    <div id="nav-step" class="text-xl md:text-2xl font-bold leading-tight mb-1">
                        Starting...
                    </div>
                    <!-- Subtext -->
                    <div class="flex flex-wrap items-center gap-2 text-green-100 text-sm font-medium leading-snug">
                        <span id="nav-dist-header" class="bg-black/20 px-2 py-0.5 rounded text-white font-bold whitespace-nowrap shrink-0">0 m</span>
                        <span class="opacity-80">towards</span>
                        <span id="nav-street-name" class="opacity-90 font-bold">Destination</span>
                    </div>
                </div>
            </div>

            <!-- Lanes Container -->
            <div id="nav-lanes" class="flex justify-center gap-4 bg-[#042f24] pb-2 pt-1 hidden"></div>
        </div>

        <!-- "Then" Pill -->
        <div id="nav-then" class="then-pill bg-[#065f46] text-white rounded-b-xl mx-4 p-2 px-4 shadow-md flex items-center gap-3 relative -mt-2 z-10 w-fit pointer-events-auto">
            <span class="font-bold text-xs md:text-sm uppercase tracking-wide opacity-80">Then</span>
            <i id="nav-then-icon" class="ph-bold ph-arrow-right text-base md:text-xl"></i>
            <span id="nav-then-text" class="font-medium text-xs md:text-sm">Turn right</span>
        </div>
    </div>

    <!-- ========================================== -->
    <!-- FLOATING ACTION BUTTONS                    -->
    <!-- ========================================== -->
    <div id="map-controls" class="map-ui absolute bottom-32 right-4 flex flex-col gap-3 transition-transform duration-300 items-end z-[900]">
        
        <!-- NEW: Simulation/GPS Toggle Button -->
        <button id="sim-btn" onclick="toggleSimulation()" class="bg-white w-12 h-12 md:w-14 md:h-14 rounded-full shadow-google flex items-center justify-center text-gray-600 hover:text-blue-600 transition active:scale-95">
            <i class="ph-fill ph-broadcast text-xl md:text-2xl"></i>
        </button>

        <button onclick="handleLocate()" class="bg-white w-12 h-12 md:w-14 md:h-14 rounded-full shadow-google flex items-center justify-center text-gray-600 hover:text-blue-600 transition active:scale-95">
            <i class="ph-fill ph-crosshair text-xl md:text-2xl"></i>
        </button>
        <button onclick="map.setZoom(map.getZoom() + 1)" class="bg-white w-14 h-14 rounded-full shadow-google hidden md:flex items-center justify-center text-gray-600 hover:text-blue-600 transition active:scale-95">
            <i class="ph ph-plus text-xl"></i>
        </button>
        <button onclick="map.setZoom(map.getZoom() - 1)" class="bg-white w-14 h-14 rounded-full shadow-google hidden md:flex items-center justify-center text-gray-600 hover:text-blue-600 transition active:scale-95">
            <i class="ph ph-minus text-xl"></i>
        </button>
    </div>

    <!-- ========================================== -->
    <!-- BOTTOM SHEET (TRIP DETAILS)                -->
    <!-- ========================================== -->
    <div id="trip-card" class="map-ui absolute bottom-0 left-0 right-0 bg-white shadow-[0_-4px_20px_rgba(0,0,0,0.1)] transform translate-y-[110%] transition-transform duration-300 rounded-t-2xl md:w-96 md:left-4 md:bottom-4 md:shadow-google z-50">
        
        <div class="w-full flex justify-center pt-2 pb-1 md:hidden">
            <div class="w-10 h-1 bg-gray-300 rounded-full"></div>
        </div>

        <div class="p-4 md:p-5">
            <div class="flex items-baseline justify-between mb-3 md:mb-4">
                <div class="flex items-baseline gap-2">
                    <span id="route-time" class="text-xl md:text-2xl font-bold text-[#188038]">-- min</span>
                    <span id="route-dist" class="text-sm md:text-base text-gray-500 font-medium">(-- km)</span>
                </div>
                <div class="bg-blue-50 text-blue-700 px-2 py-0.5 md:py-1 rounded-md text-[10px] md:text-xs font-bold uppercase tracking-wide">
                    Fastest
                </div>
            </div>

            <div class="flex items-center gap-3 md:gap-4 mb-4 md:mb-6">
                <div class="w-8 h-8 md:w-10 md:h-10 rounded-full bg-gray-100 flex items-center justify-center shrink-0">
                    <i class="ph-fill ph-map-pin text-red-500 text-lg md:text-xl"></i>
                </div>
                <div class="min-w-0">
                    <div id="route-dest" class="font-medium text-gray-900 truncate text-base md:text-lg">Destination</div>
                    <div class="text-xs md:text-sm text-gray-500 truncate">Typically light traffic</div>
                </div>
            </div>

            <div class="flex gap-2 md:gap-3">
                <button id="close-trip-btn" onclick="clearMapState()" class="flex-1 py-2 md:py-3 rounded-full border border-gray-300 font-medium text-sm md:text-base text-gray-700 hover:bg-gray-50 transition active:bg-gray-100">
                    Cancel
                </button>
                <button id="start-btn" onclick="startNavigation()" class="flex-[2] bg-[#4285F4] hover:bg-[#3367d6] text-white font-bold py-2 md:py-3 rounded-full shadow-md transition flex items-center justify-center gap-2 active:shadow-none active:scale-[0.98]">
                    <i class="ph-bold ph-navigation-arrow text-base md:text-lg -rotate-45"></i> <span class="text-sm md:text-base">Start</span>
                </button>
            </div>
        </div>
    </div>

    <!-- ========================================== -->
    <!-- BOTTOM BAR (NAV ACTIVE)                    -->
    <!-- ========================================== -->
    <div id="nav-footer" class="map-ui absolute bottom-0 left-0 right-0 bg-white p-4 md:p-10 rounded-t-3xl md:rounded-3xl shadow-[0_-5px_15px_rgba(0,0,0,0.1)] transform translate-y-[150%] transition-transform duration-300 flex items-center justify-between z-[2000] md:max-w-md md:left-6 md:bottom-6 md:right-auto md:shadow-google">
        
        <!-- Speed Limit Sign -->
        <div id="speed-limit" class="speed-limit-sign hidden absolute -top-20 md:-top-28 left-4 md:left-10 transform transition-all hover:scale-105">
            <span id="speed-val">50</span>
        </div>

        <div class="flex-1">
            <div class="text-[#188038] font-bold text-2xl md:text-4xl mb-0.5 md:mb-1" id="nav-footer-time">0 min</div>
            <div class="text-gray-500 text-sm md:text-lg">
                <span id="nav-footer-dist">0 km</span> â€¢ <span id="nav-footer-eta">12:00</span>
            </div>
        </div>
        
        <button onclick="stopNavigation()" class="bg-gray-100 hover:bg-gray-200 text-gray-700 px-6 py-3 md:px-10 md:py-5 rounded-full font-bold text-sm md:text-lg uppercase tracking-wide transition">
            Exit
        </button>
    </div>

    <!-- Toast -->
    <div id="toast" class="map-ui absolute top-2/3 left-1/2 -translate-x-1/2 bg-[#323232] text-white px-6 py-3 rounded-full text-sm font-normal shadow-lg opacity-0 transition-all duration-300 pointer-events-none transform translate-y-4">
        Message
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <script src="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.js"></script>

    <script>
        // --- Setup ---
        const DEFAULT_COORDS = { lat: 39.4812, lng: -0.3473 };
        const LOOKAHEAD_METERS = 20;
        const REROUTE_THRESHOLD_METERS = 20;

        const map = L.map('map', { zoomControl: false, attributionControl: false }).setView([DEFAULT_COORDS.lat, DEFAULT_COORDS.lng], 16);
        
        L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
            attribution: '&copy; CARTO',
            subdomains: 'abcd',
            maxZoom: 20
        }).addTo(map);

        // --- State ---
        let userLocation = null, destLocation = null;
        let routingControl = null;
        let userMarker = null, destMarker = null;
        let routeCoords = [], routeInstructions = [];
        let routeDistanceIndex = [];
        let totalRouteSeconds = 0;
        let rawRouteData = null; 
        let isNavigating = false;
        let animationFrameId = null;
        let currentVisualHeading = 0;
        let speedLimitInterval = null; 
        
        // Simulation / GPS Logic
        let isSimulationEnabled = true; // Default to Simulation
        let gpsWatchId = null;
        let navIndex = 0; // Current index in simulation route

        // --- Icons ---
        const createIcon = (type) => {
            if (type === 'user') {
                return L.divIcon({
                    className: 'user-pulse',
                    html: `<div class="w-5 h-5 bg-[#4285F4] border-[3px] border-white rounded-full shadow-md relative z-10"></div>`,
                    iconSize: [20, 20], iconAnchor: [10, 10]
                });
            } else if (type === 'arrow') {
                return L.divIcon({
                    className: 'nav-arrow-icon',
                    html: `
                        <div class="arrow-icon-inner" style="width: 50px; height: 50px; display: flex; align-items: center; justify-content: center;">
                            <svg width="50" height="50" viewBox="0 0 50 50" fill="none">
                                <circle cx="25" cy="25" r="20" fill="#4285F4" stroke="white" stroke-width="3" class="shadow-lg"></circle>
                                <path d="M25 12L32 30L25 26L18 30L25 12Z" fill="white"></path>
                            </svg>
                        </div>`,
                    iconSize: [50, 50], iconAnchor: [25, 25]
                });
            } else {
                return L.divIcon({
                    className: 'custom-pin',
                    html: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="#EA4335" class="drop-shadow-lg w-10 h-10"><path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7z"></path><circle cx="12" cy="9" r="2.5" fill="#751510"></circle></svg>`,
                    iconSize: [40, 40], iconAnchor: [20, 40], popupAnchor: [0, -42]
                });
            }
        };

        map.on('click', e => { 
            if(!isNavigating) {
                document.getElementById('search-results').classList.add('hidden');
                setDestination(e.latlng, "Dropped Pin"); 
            }
        });

        function setDestination(latlng, name) {
            destLocation = latlng;
            if(destMarker) map.removeLayer(destMarker);
            destMarker = L.marker(latlng, {icon: createIcon('dest')}).addTo(map);
            const shortName = name.split(',')[0];
            document.getElementById('route-dest').textContent = shortName;
            document.getElementById('search-input').value = shortName;
            if(userLocation) calculateRoute();
            else handleLocate(true);
        }

        function handleLocate(autoRoute = false) {
            if(isNavigating) return;
            if(!navigator.geolocation) return useFallback(autoRoute);
            showToast("Locating you...");
            navigator.geolocation.getCurrentPosition(
                pos => updateUserLoc(pos.coords.latitude, pos.coords.longitude, autoRoute),
                () => useFallback(autoRoute), 
                { timeout: 5000, enableHighAccuracy: true }
            );
        }

        function useFallback(auto) { 
            updateUserLoc(DEFAULT_COORDS.lat, DEFAULT_COORDS.lng, auto, true); 
        }

        function updateUserLoc(lat, lng, auto, fallback) {
            userLocation = L.latLng(lat, lng);
            if(userMarker) map.removeLayer(userMarker);
            userMarker = L.marker(userLocation, {icon: createIcon('user')}).addTo(map);
            if(!auto) {
                map.setView(userLocation, 16, { animate: true });
                if(fallback) showToast("GPS failed. Welcome to UPV!");
            }
            if(destLocation) calculateRoute();
        }

        function toggleSimulation() {
            isSimulationEnabled = !isSimulationEnabled;
            const btn = document.getElementById('sim-btn');
            
            if (!isSimulationEnabled) {
                // Swithced to Real GPS
                btn.classList.add('mode-active');
                showToast("Real GPS Navigation Active");
                if (isNavigating) {
                    cancelAnimationFrame(animationFrameId); // Stop simulation loop
                    startGPSWatch(); // Start watching position
                }
            } else {
                // Switched to Simulation
                btn.classList.remove('mode-active');
                showToast("Simulation Mode Active");
                if (isNavigating) {
                    stopGPSWatch();
                    // Need to find nearest point on route to resume simulation nicely
                    if(userMarker) {
                        const currentLL = userMarker.getLatLng();
                        navIndex = findClosestRouteIndex(currentLL);
                    }
                    animateRoute(); // Resume/Start simulation loop
                }
            }
        }

        function startGPSWatch() {
            if (!navigator.geolocation) {
                showToast("Geolocation not supported");
                return;
            }
            stopGPSWatch(); // Clear existing
            gpsWatchId = navigator.geolocation.watchPosition(
                handleGPSUpdate,
                (err) => console.warn("GPS Error", err),
                { enableHighAccuracy: true, maximumAge: 1000 }
            );
        }

        function stopGPSWatch() {
            if (gpsWatchId !== null) {
                navigator.geolocation.clearWatch(gpsWatchId);
                gpsWatchId = null;
            }
        }

        function handleGPSUpdate(pos) {
            if (!isNavigating || isSimulationEnabled) return;

            const lat = pos.coords.latitude;
            const lng = pos.coords.longitude;
            const newPos = L.latLng(lat, lng);
            
            // 1. Get Snapped Point & Info
            const snapInfo = getClosestPointOnRoute(newPos);
            const snappedPos = snapInfo.point;
            const distToRoute = snapInfo.dist;
            const segIndex = snapInfo.index;

            // 2. Decide: Stick or Drift
            let displayPos;
            
            if (distToRoute > REROUTE_THRESHOLD_METERS) {
                console.log("Off route detected: " + distToRoute + "m. Recalculating...");
                showToast("Recalculating route...");
                userLocation = newPos;
                calculateRoute(); // Will restart nav
                return; // Stop here until new route
            } else {
                // Stick mode
                displayPos = snappedPos;
                navIndex = segIndex; // Sync simulation state to this point
            }

            // 3. Update Marker
            if (userMarker) {
                userMarker.setLatLng(displayPos);
            }

            // 4. Orientation & Camera (Look ahead from SNAPPED position)
            const lookaheadPt = getLookaheadPoint(segIndex, displayPos, LOOKAHEAD_METERS);
            if (lookaheadPt) {
                const bearing = getBearing(displayPos.lat, displayPos.lng, lookaheadPt.lat, lookaheadPt.lng);
                currentVisualHeading = bearing; 
                updateCamera(displayPos, currentVisualHeading);
            } else {
                updateCamera(displayPos, currentVisualHeading);
            }

            // 5. Update UI
            updateInstructions(segIndex, displayPos);
            updateTripDashboard(segIndex, 0);
        }

        // --- NEW Helper: Find exact closest point on the route polyline ---
        function getClosestPointOnRoute(latlng) {
            let minDist = Infinity;
            let bestPoint = latlng;
            let bestIndex = 0;

            for(let i=0; i<routeCoords.length-1; i++) {
                // Convert lat/lng to container points for 2D projection math
                // This is robust for small distances (<1km) which is our case
                const p = map.latLngToLayerPoint(latlng);
                const p1 = map.latLngToLayerPoint(routeCoords[i]);
                const p2 = map.latLngToLayerPoint(routeCoords[i+1]);
                
                // Leaflet util to project point onto segment
                const closestP = L.LineUtil.closestPointOnSegment(p, p1, p2);
                const closestLL = map.layerPointToLatLng(closestP);
                const d = map.distance(latlng, closestLL);
                
                if(d < minDist) {
                    minDist = d;
                    bestPoint = closestLL;
                    bestIndex = i;
                }
            }
            return { point: bestPoint, dist: minDist, index: bestIndex };
        }

        function findClosestRouteIndex(latlng) {
            let minD = Infinity;
            let idx = 0;
            for (let i = 0; i < routeCoords.length; i++) {
                const d = map.distance(latlng, routeCoords[i]);
                if (d < minD) {
                    minD = d;
                    idx = i;
                }
            }
            return idx;
        }

        async function calculateRoute() {
            if(!userLocation || !destLocation) return;
            if(routingControl) map.removeControl(routingControl);
            rawRouteData = null;

            try {
                const url = `https://router.project-osrm.org/route/v1/driving/${userLocation.lng},${userLocation.lat};${destLocation.lng},${destLocation.lat}?overview=full&steps=true&geometries=geojson&annotations=true`;
                const response = await fetch(url);
                rawRouteData = await response.json();
            } catch(e) {
                console.error("OSM Fetch Error", e);
            }
            
            routingControl = L.Routing.control({
                waypoints: [userLocation, destLocation],
                router: L.Routing.osrmv1({ serviceUrl: 'https://router.project-osrm.org/route/v1', profile: 'driving' }),
                lineOptions: { 
                    styles: [
                        {color: '#1557b0', opacity: 0.4, weight: 13}, 
                        {color: '#4285F4', opacity: 1, weight: 9, lineCap: 'round', lineJoin: 'round'}
                    ],
                    addWaypoints: false 
                },
                createMarker: () => null,
                addWaypoints: false, draggableWaypoints: false, 
                // Don't auto-fit bounds if we are already navigating
                fitSelectedRoutes: !isNavigating,
                show: false 
            }).on('routesfound', e => {
                const route = e.routes[0];
                routeCoords = route.coordinates;
                routeInstructions = route.instructions; 

                routeDistanceIndex = [0];
                let totalDist = 0;
                for(let i = 0; i < routeCoords.length - 1; i++) {
                    totalDist += map.distance(routeCoords[i], routeCoords[i+1]);
                    routeDistanceIndex.push(totalDist);
                }
                
                totalRouteSeconds = route.summary.totalTime;
                
                // If we are already navigating (e.g. reroute), don't show preview, just keep going
                if (isNavigating) {
                    navIndex = 0; // Reset sim index
                    return; 
                }

                // Initial Preview Setup
                const hours = Math.floor(totalRouteSeconds / 3600);
                const mins = Math.round((totalRouteSeconds % 3600) / 60);
                let timeStr = mins + " min";
                if(hours > 0) timeStr = hours + " hr " + mins + " min";
                
                const km = (route.summary.totalDistance / 1000).toFixed(1);
                
                document.getElementById('route-time').textContent = timeStr;
                document.getElementById('route-dist').textContent = `(${km} km)`;
                document.getElementById('nav-footer-time').textContent = timeStr;
                document.getElementById('nav-footer-dist').textContent = km + " km";
                
                const now = new Date();
                now.setSeconds(now.getSeconds() + totalRouteSeconds);
                document.getElementById('nav-footer-eta').textContent = now.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});

                document.getElementById('trip-card').classList.remove('translate-y-[110%]');
                document.getElementById('trip-card').classList.add('translate-y-0');
                document.getElementById('map-controls').classList.add('-translate-y-[200px]');
            }).addTo(map);
        }

        function startNavigation() {
            if(!routeCoords.length) return;
            isNavigating = true;
            navIndex = 0; // Reset sim index
            
            document.getElementById('explore-ui').classList.add('-translate-y-full');
            document.getElementById('trip-card').classList.add('translate-y-[110%]');
            document.getElementById('trip-card').classList.remove('translate-y-0');
            
            const controls = document.getElementById('map-controls');
            controls.classList.remove('translate-y-[200px]');
            controls.classList.add('-translate-y-[250px]');
            
            document.getElementById('nav-header').classList.remove('-translate-y-[150%]');
            document.getElementById('nav-footer').classList.remove('translate-y-[150%]');
            document.getElementById('map-wrapper').style.perspective = "1200px";
            
            if(userMarker) map.removeLayer(userMarker);
            const startPos = routeCoords[0];
            userMarker = L.marker(startPos, { icon: createIcon('arrow'), zIndexOffset: 1000 }).addTo(map);

            const startLatLng = L.latLng(startPos.lat, startPos.lng);
            
            // --- FIXED: Visuals - Reverted to Scale 2x & Zoom 18 ---
            map.setZoom(18, {animate: true});
            updateCamera(startLatLng, 0);

            fetchSpeedLimit();
            speedLimitInterval = setInterval(fetchSpeedLimit, 6000); 

            if (isSimulationEnabled) {
                animateRoute();
            } else {
                startGPSWatch();
            }
        }

        function updateCamera(pos, bearing) {
            // Re-apply scale(2.0) for thicker roads
            document.getElementById('map').style.transform = `rotateX(60deg) rotateZ(${-bearing}deg) scale(2.0)`;
            
            const el = userMarker ? userMarker.getElement() : null;
            if (el) {
                const inner = el.querySelector('.arrow-icon-inner');
                if(inner) inner.style.transform = `rotate(${bearing}deg)`;
            }
            
            // Adjust Offset: Scale 2.0 changes visual center logic
            // To keep car at bottom ~25%, we calculate offset based on 2x scaled pixels
            const offsetCenter = shiftLatLng(pos.lat, pos.lng, 35, bearing);
            
            // Force strict zoom 18
            map.setView(offsetCenter, 18, {animate: false}); 
        }

        function shiftLatLng(lat, lng, meters, bearing) {
            const R = 6378137;
            const d = meters;
            const brng = bearing * Math.PI / 180;
            const phi1 = lat * Math.PI / 180;
            const lam1 = lng * Math.PI / 180;
            const phi2 = Math.asin(Math.sin(phi1) * Math.cos(d/R) + Math.cos(phi1) * Math.sin(d/R) * Math.cos(brng));
            const lam2 = lam1 + Math.atan2(Math.sin(brng) * Math.sin(d/R) * Math.cos(phi1), Math.cos(d/R) - Math.sin(phi1) * Math.sin(phi2));
            return L.latLng(phi2 * 180 / Math.PI, lam2 * 180 / Math.PI);
        }

        function animateRoute() {
            let startTime = null;
            let currentSpeed = 500; 
            
            const lerp = (a, b, t) => a + (b - a) * t;

            function angularDiff(a, b) {
                let d = (b - a + 540) % 360 - 180;
                return d;
            }

            function step(timestamp) {
                // FIXED: Safety check + Stop condition
                if(!isNavigating || !isSimulationEnabled) return;
                
                if(!startTime) startTime = timestamp;
                const progress = timestamp - startTime;
                
                // Ensure percent is safely clamped
                const percent = Math.min(progress / currentSpeed, 1);

                if (navIndex >= routeCoords.length - 1) {
                    stopNavigation();
                    return;
                }

                const start = routeCoords[navIndex];
                const end = routeCoords[navIndex+1];
                
                // Fallback if bad data
                if(!start || !end) {
                    stopNavigation();
                    return;
                }
                
                const lat = lerp(start.lat, end.lat, percent);
                const lng = lerp(start.lng, end.lng, percent);
                const currPos = L.latLng(lat, lng);

                const lookaheadPt = getLookaheadPoint(navIndex, currPos, LOOKAHEAD_METERS); 
                if(lookaheadPt) {
                    const bearing = getBearing(currPos.lat, currPos.lng, lookaheadPt.lat, lookaheadPt.lng);
                    if (userMarker) {
                        userMarker.setLatLng(currPos);
                        const diff = angularDiff(currentVisualHeading, bearing);
                        currentVisualHeading = currentVisualHeading + diff * 0.15;
                        updateCamera(currPos, currentVisualHeading);
                    }
                }

                updateInstructions(navIndex, currPos);
                updateTripDashboard(navIndex, percent);
                
                // Turn prediction
                if(navIndex + 3 < routeCoords.length) {
                    const b1 = getBearing(routeCoords[navIndex].lat, routeCoords[navIndex].lng, routeCoords[navIndex+1].lat, routeCoords[navIndex+1].lng);
                    const b2 = getBearing(routeCoords[navIndex+2].lat, routeCoords[navIndex+2].lng, routeCoords[navIndex+3].lat, routeCoords[navIndex+3].lng);
                    const turnAngle = Math.abs(angularDiff(b1, b2));
                    currentSpeed = turnAngle > 15 ? 1200 : 300; 
                }

                if(percent >= 1) {
                    // Reset startTime ONLY when moving to next segment
                    startTime = null; 
                    navIndex++;
                }
                
                animationFrameId = requestAnimationFrame(step);
            }
            animationFrameId = requestAnimationFrame(step);
        }

        // ... [Rest of getLookaheadPoint, updateInstructions, etc.] ...

        function getLookaheadPoint(currentIndex, currentPosLatLng, lookaheadMeters) {
            let distAcc = 0;
            let prevLatLng = currentPosLatLng;
            for (let i = currentIndex + 1; i < routeCoords.length; i++) {
                const pt = routeCoords[i];
                const nextLatLng = L.latLng(pt.lat, pt.lng);
                const d = map.distance(prevLatLng, nextLatLng);
                if (distAcc + d >= lookaheadMeters) {
                    const ratio = (lookaheadMeters - distAcc) / d;
                    const lat = prevLatLng.lat + (nextLatLng.lat - prevLatLng.lat) * ratio;
                    const lng = prevLatLng.lng + (nextLatLng.lng - prevLatLng.lng) * ratio;
                    return L.latLng(lat, lng);
                }
                distAcc += d;
                prevLatLng = nextLatLng;
            }
            return routeCoords.length ? L.latLng(routeCoords[routeCoords.length-1]) : null;
        }

        function updateTripDashboard(index, percent) {
            if (routeDistanceIndex.length === 0) return;
            const distAtIndex = routeDistanceIndex[index];
            const distNext = routeDistanceIndex[Math.min(index + 1, routeDistanceIndex.length - 1)];
            const currentDist = distAtIndex + (distNext - distAtIndex) * percent;
            const totalDist = routeDistanceIndex[routeDistanceIndex.length - 1];
            const remainingDist = Math.max(0, totalDist - currentDist);
            const remainingSeconds = (remainingDist / totalDist) * totalRouteSeconds;

            const h = Math.floor(remainingSeconds / 3600);
            const m = Math.ceil((remainingSeconds % 3600) / 60);
            let timeStr = m + " min";
            if (h > 0) timeStr = h + " hr " + m + " min";
            if (remainingSeconds < 60) timeStr = "0 min";

            document.getElementById('nav-footer-time').textContent = timeStr;
            document.getElementById('nav-footer-dist').textContent = (remainingDist / 1000).toFixed(1) + " km";
            const etaDate = new Date();
            etaDate.setSeconds(etaDate.getSeconds() + remainingSeconds);
            document.getElementById('nav-footer-eta').textContent = etaDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        }

        function updateInstructions(idx, currPos) {
            const instr = routeInstructions.find(i => i.index >= idx) || routeInstructions[routeInstructions.length - 1];
            if(!instr) return;

            let text = instr.text;
            if(text.includes('Head')) text = "Continue";
            text = text.replace(/traffic circle/gi, "roundabout").replace(/center/gi, "centre");

            document.getElementById('nav-step').textContent = "Starting..."; 
            
            const stepEl = document.getElementById('nav-step');
            const streetEl = document.getElementById('nav-street-name');
            const distHeaderEl = document.getElementById('nav-dist-header');
            
            const destIndex = Math.min(instr.index, routeCoords.length - 1);
            const d = map.distance(currPos, routeCoords[destIndex]);
            let distText = d >= 1000 ? (d/1000).toFixed(1) + " km" : Math.round(d/10)*10 + " m";
            distHeaderEl.textContent = distText;

            if(text.includes(' onto ')) {
                const parts = text.split(' onto ');
                stepEl.textContent = parts[0];
                streetEl.textContent = parts[1];
            } else {
                stepEl.textContent = text;
                streetEl.textContent = "on route";
            }

            document.getElementById('nav-icon').innerHTML = getNavSignSvg(instr, text);

            const rbLabelEl = document.getElementById('roundabout-exit-label');
            rbLabelEl.classList.add('hidden');
            if (rawRouteData && rawRouteData.routes[0].legs) {
                 const leg = rawRouteData.routes[0].legs[0];
                 const instrIdx = routeInstructions.indexOf(instr);
                 const rbContext = getRoundaboutContext(leg, instrIdx, text);
                 if (rbContext && rbContext.label) {
                     rbLabelEl.textContent = rbContext.label;
                     rbLabelEl.classList.remove('hidden');
                 }
            }

            const thenPill = document.getElementById('nav-then');
            const nextInstrIndex = routeInstructions.indexOf(instr) + 1;
            if (nextInstrIndex < routeInstructions.length && d < 300) {
                const nextInstr = routeInstructions[nextInstrIndex];
                const nType = (nextInstr.type || '').toLowerCase();
                const nMod = (nextInstr.modifier || '').toLowerCase();
                const nText = (nextInstr.text || '').toLowerCase();
                
                let shortNext = "Straight";
                let iconClass = "ph-arrow-up";

                if (nType === 'arrive' || nText.includes('arrive')) { shortNext = "Arrive"; iconClass = "ph-map-pin"; }
                else if (nType.includes('roundabout')) { shortNext = "Roundabout"; iconClass = "ph-arrows-clockwise"; }
                else if (nMod.includes('right')) { shortNext = "Turn Right"; iconClass = "ph-arrow-right"; }
                else if (nMod.includes('left')) { shortNext = "Turn Left"; iconClass = "ph-arrow-left"; }
                else if (nType.includes('ramp')) { shortNext = "Ramp"; iconClass = "ph-arrow-elbow-right-up"; }

                document.getElementById('nav-then-text').textContent = shortNext;
                document.getElementById('nav-then-icon').className = `ph-bold ${iconClass} text-base md:text-xl`;
                thenPill.classList.add('visible');
            } else {
                thenPill.classList.remove('visible');
            }

             if(rawRouteData && rawRouteData.routes[0].legs) {
                const leg = rawRouteData.routes[0].legs[0];
                const rawStep = leg.steps[routeInstructions.indexOf(instr)];
                if(d < 1000 && rawStep && rawStep.intersections && rawStep.intersections[0] && rawStep.intersections[0].lanes) {
                    renderRealLanes(rawStep.intersections[0].lanes);
                } else {
                    document.getElementById('nav-lanes').classList.add('hidden');
                }
             }
        }

        // --- Helper: Roundabout Logic ---
        function getOrdinalSuffix(n) {
            n = parseInt(n, 10);
            if (isNaN(n)) return '';
            const s = ["th", "st", "nd", "rd"];
            const v = n % 100;
            const suffix = s[(v - 20) % 10] || s[v] || s[0];
            return `${n}${suffix}`;
        }

        function renderRealLanes(osrmLanes) {
            const container = document.getElementById('nav-lanes');
            container.innerHTML = '';
            container.classList.remove('hidden');
            osrmLanes.forEach(lane => {
                const el = document.createElement('div');
                const isActive = lane.valid;
                let icon = 'ph-arrow-up';
                if(lane.indications.includes('right')) icon = 'ph-arrow-up-right';
                if(lane.indications.includes('left')) icon = 'ph-arrow-up-left';
                el.className = `lane-icon ${isActive ? 'active' : ''}`;
                el.innerHTML = `<i class="ph-bold ${icon}"></i>`;
                container.appendChild(el);
            });
        }

        function getNavSignSvg(instr, text) {
             // Robust SVG logic
             const type = (instr.type || '').toLowerCase();
             const modifier = (instr.modifier || '').toLowerCase();
             const lowerText = text.toLowerCase();
             let key = 'straight';
             if (type === 'arrive' || lowerText.includes('arrive')) key = 'arrive';
             else if (type.includes('roundabout')) key = 'roundabout';
             else if (type === 'fork') key = modifier.includes('left') ? 'fork-left' : 'fork-right';
             else if (type === 'merge') key = modifier.includes('left') ? 'merge-left' : 'merge-right';
             else if (type.includes('ramp')) key = modifier.includes('left') ? 'ramp-left' : 'ramp-right';
             else if (modifier.includes('sharp right')) key = 'sharp-right';
             else if (modifier.includes('sharp left')) key = 'sharp-left';
             else if (modifier.includes('right')) key = 'right';
             else if (modifier.includes('left')) key = 'left';

             const svgMap = {
                'right': `<svg viewBox="0 0 100 100"><path d="M30 80 V50 A20 20 0 0 1 50 30 H80" fill="none" stroke="white" stroke-width="12" stroke-linecap="round"/><path d="M65 15 L80 30 L65 45" fill="none" stroke="white" stroke-width="12" stroke-linecap="round" stroke-linejoin="round"/></svg>`,
                'left': `<svg viewBox="0 0 100 100"><path d="M70 80 V50 A20 20 0 0 0 50 30 H20" fill="none" stroke="white" stroke-width="12" stroke-linecap="round"/><path d="M35 15 L20 30 L35 45" fill="none" stroke="white" stroke-width="12" stroke-linecap="round" stroke-linejoin="round"/></svg>`,
                'sharp-right': `<svg viewBox="0 0 100 100"><path d="M25 80 V50 A20 20 0 0 1 45 30 H55 A20 20 0 0 1 75 50 V60" fill="none" stroke="white" stroke-width="12" stroke-linecap="round"/><path d="M60 45 L75 60 L90 45" fill="none" stroke="white" stroke-width="12" stroke-linecap="round" stroke-linejoin="round"/></svg>`,
                'sharp-left': `<svg viewBox="0 0 100 100"><path d="M75 80 V50 A20 20 0 0 0 55 30 H45 A20 20 0 0 0 25 50 V60" fill="none" stroke="white" stroke-width="12" stroke-linecap="round"/><path d="M10 45 L25 60 L40 45" fill="none" stroke="white" stroke-width="12" stroke-linecap="round" stroke-linejoin="round"/></svg>`,
                'straight': `<svg viewBox="0 0 100 100"><path d="M50 85 L50 15" fill="none" stroke="white" stroke-width="12" stroke-linecap="round"/><path d="M35 30 L50 15 L65 30" fill="none" stroke="white" stroke-width="12" stroke-linecap="round" stroke-linejoin="round"/></svg>`,
                'roundabout': `<svg viewBox="0 0 100 100"><path d="M50 70 A 25 25 0 1 0 25 45 L 25 55" fill="none" stroke="white" stroke-width="12" stroke-linecap="round"/><path d="M15 45 L 25 55 L 35 45" fill="none" stroke="white" stroke-width="12" stroke-linecap="round" stroke-linejoin="round"/></svg>`,
                'arrive': `<svg viewBox="0 0 100 100"><path d="M50 85 C 50 85 25 55 25 35 A 25 25 0 1 1 75 35 C 75 55 50 85 50 85" fill="#EF4444" stroke="white" stroke-width="4"/><circle cx="50" cy="35" r="10" fill="white"/></svg>`,
                // Default fallbacks for complex ones (visuals)
                'merge-left': `<svg viewBox="0 0 100 100"><path d="M35 35 L50 20 L65 35" fill="none" stroke="white" stroke-width="12" stroke-linecap="round"/><path d="M50 20 L50 85" fill="none" stroke="white" stroke-width="12" stroke-linecap="round"/><path d="M50 55 L25 85" fill="none" stroke="white" stroke-width="12" stroke-linecap="round"/></svg>`,
                'merge-right': `<svg viewBox="0 0 100 100"><path d="M35 35 L50 20 L65 35" fill="none" stroke="white" stroke-width="12" stroke-linecap="round"/><path d="M50 20 L50 85" fill="none" stroke="white" stroke-width="12" stroke-linecap="round"/><path d="M50 55 L75 85" fill="none" stroke="white" stroke-width="12" stroke-linecap="round"/></svg>`,
                'ramp-right': `<svg viewBox="0 0 100 100"><path d="M35 85 L35 15" fill="none" stroke="white" stroke-width="12" stroke-linecap="round" stroke-opacity="0.4"/><path d="M35 60 Q35 40 60 30 L75 25" fill="none" stroke="white" stroke-width="12" stroke-linecap="round"/><path d="M60 15 L75 25 L65 40" fill="none" stroke="white" stroke-width="12" stroke-linecap="round" stroke-linejoin="round"/></svg>`,
                'ramp-left': `<svg viewBox="0 0 100 100"><path d="M65 85 L65 15" fill="none" stroke="white" stroke-width="12" stroke-linecap="round" stroke-opacity="0.4"/><path d="M65 60 Q65 40 40 30 L25 25" fill="none" stroke="white" stroke-width="12" stroke-linecap="round"/><path d="M35 40 L25 25 L40 15" fill="none" stroke="white" stroke-width="12" stroke-linecap="round" stroke-linejoin="round"/></svg>`
             };
             return svgMap[key] || svgMap['straight'];
        }

        // (Roundabout context and others same as before)
        function getRoundaboutContext(leg, currentIndex, text) {
            if (!leg || !leg.steps || currentIndex < 0) return null;
            const getExit = (step) => {
                if(!step || !step.maneuver) return null;
                const t = (step.maneuver.type || '').toLowerCase();
                if (t.includes('roundabout') || t.includes('rotary')) return step.maneuver.exit || step.exit || (step.exits ? parseInt(step.exits, 10) : null);
                return null;
            };
            let exit = getExit(leg.steps[currentIndex]);
            if (exit) return { label: getOrdinalSuffix(exit) };
            if (text.toLowerCase().includes('exit') && (text.toLowerCase().includes('roundabout'))) {
                for (let i = 1; i <= 3; i++) {
                    const prevIndex = currentIndex - i;
                    if (prevIndex >= 0) {
                        exit = getExit(leg.steps[prevIndex]);
                        if (exit) return { label: getOrdinalSuffix(exit) };
                    }
                }
            }
            return null;
        }

        function getBearing(lat1, lng1, lat2, lng2) {
            const y = Math.sin((lng2-lng1) * Math.PI/180) * Math.cos(lat2 * Math.PI/180);
            const x = Math.cos(lat1 * Math.PI/180) * Math.sin(lat2 * Math.PI/180) - Math.sin(lat1 * Math.PI/180) * Math.cos(lat2 * Math.PI/180) * Math.cos((lng2-lng1) * Math.PI/180);
            return ((Math.atan2(y, x) * 180/Math.PI) + 360) % 360;
        }

        function stopNavigation() {
            isNavigating = false;
            cancelAnimationFrame(animationFrameId);
            stopGPSWatch();
            if(speedLimitInterval) clearInterval(speedLimitInterval);
            
            document.getElementById('map').style.transform = '';
            document.getElementById('explore-ui').classList.remove('-translate-y-full');
            document.getElementById('nav-header').classList.add('-translate-y-[150%]');
            document.getElementById('nav-footer').classList.add('translate-y-[150%]');
            
            const controls = document.getElementById('map-controls');
            controls.classList.remove('-translate-y-[250px]');
            controls.classList.remove('translate-y-[200px]');

            document.getElementById('trip-card').classList.remove('translate-y-[110%]');
            document.getElementById('trip-card').classList.add('translate-y-0');
            
            controls.classList.add('-translate-y-[200px]');
            document.getElementById('speed-limit').classList.add('hidden');
            document.getElementById('roundabout-exit-label').classList.add('hidden');

            if(userMarker) {
                const ll = userMarker.getLatLng();
                map.removeLayer(userMarker);
                userMarker = L.marker(ll, {icon: createIcon('user')}).addTo(map);
                map.setZoom(16);
            }
        }

        function clearMapState() {
            if(isNavigating) stopNavigation();
            
            document.getElementById('nav-header').classList.add('-translate-y-[150%]');
            document.getElementById('nav-footer').classList.add('translate-y-[150%]');
            document.getElementById('explore-ui').classList.remove('-translate-y-full');
            
            const controls = document.getElementById('map-controls');
            controls.classList.remove('-translate-y-[250px]');
            controls.classList.remove('translate-y-[200px]');

            if(routingControl) { map.removeControl(routingControl); routingControl = null; }
            if(destMarker) { map.removeLayer(destMarker); destMarker = null; destLocation = null; }
            document.getElementById('trip-card').classList.add('translate-y-[110%]');
            document.getElementById('trip-card').classList.remove('translate-y-0');
            document.getElementById('search-input').value = '';
            map.setZoom(16);
        }

        function showToast(msg) {
            const t = document.getElementById('toast');
            t.textContent = msg;
            t.classList.remove('opacity-0', 'translate-y-4');
            setTimeout(() => t.classList.add('opacity-0', 'translate-y-4'), 3000);
        }

        async function searchLocation() {
            const q = document.getElementById('search-input').value;
            if(!q) return;
            const res = document.getElementById('search-results');
            res.innerHTML = '<div class="p-4 text-center text-gray-500 text-sm">Searching...</div>';
            res.classList.remove('hidden');
            try {
                const data = await (await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(q)}`)).json();
                res.innerHTML = '';
                if(!data.length) return res.innerHTML = '<div class="p-4 text-center text-gray-500 text-sm">No results found</div>';
                data.slice(0, 5).forEach(p => {
                    const d = document.createElement('div');
                    d.className = 'p-4 hover:bg-gray-50 cursor-pointer border-b border-gray-100 flex items-center gap-3 transition';
                    d.innerHTML = `
                        <div class="bg-gray-100 p-2 rounded-full text-gray-500"><i class="ph-fill ph-map-pin"></i></div>
                        <div class="min-w-0">
                            <span class="font-medium text-gray-800 text-sm block truncate">${p.display_name.split(',')[0]}</span>
                            <span class="text-xs text-gray-500 block truncate">${p.display_name}</span>
                        </div>`;
                    d.onclick = () => { 
                        res.classList.add('hidden'); 
                        setDestination(L.latLng(p.lat, p.lon), p.display_name); 
                    };
                    res.appendChild(d);
                });
            } catch(e) { console.error(e); res.classList.add('hidden'); }
        }

        function handleEnter(e) { if(e.key === 'Enter') searchLocation(); }

        handleLocate(true);
        
        async function fetchSpeedLimit() {
            if(!isNavigating || !userMarker) return;
            // Simulated simplified fetch
            const el = document.getElementById('speed-limit');
            if(Math.random() > 0.4) {
                 el.classList.remove('hidden');
                 document.getElementById('speed-val').textContent = ["50","80","100"][Math.floor(Math.random()*3)];
            } else {
                 el.classList.add('hidden');
            }
        }
    </script>
</body>
</html>
